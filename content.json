[{"title":"到底什么是RougeLike游戏？","date":"2017-04-01T10:18:14.000Z","path":"2017/04/01/WhatIsRougeLike/","text":"引言如果你是一位资深游戏玩家，那么最近你肯定在哪里看到过 RougeLike 这个词。RougeLike 这个古老的游戏类型现在又变得很潮流，其中各种要素都在不断的被新游戏借鉴。作为一名就是比你有更多空余时间的高玩，我想在这里介绍一下我了解的 RougeLike 相关的东西。文章很长，但应该会比较有意思。 不如从故事开始任何一个 Dota 玩家都有类似”空血磕魔棒切假腿绕树林摇大五杀”这样津津乐道的故事。神奇的是 RougeLike 作为一个单机游戏类别，也有很多让人能够记住很久的故事。到这里我第一个想到的是一个已经记不清是何时在哪里看到的一个 Dwarf Fortress 里发生的故事： “有一次我的城堡里遭受了巨人的袭击。我派出我的所有部队守卫在城堡大门外。然而情况比我想象的要糟糕很多，在一段艰难的战斗后，部队伤亡已经非常惨重，而还有一个巨人始终没有被干掉。我想了想决定先把人都撤回来，后面再看看有什么办法。根据之前的经验我很明白现在这种城墙其实也是没办法挡住巨人的进攻，而且只要有一个巨人进来基本游戏就结束了，但眼前没有什么别的办法。我想说不定这就是我这次游戏的终点了。于是我下达了撤兵的命令，大部分矮人都在艰难的往城门移动。这时我发现有一个单位始终没有任何动作，我查看了一下她的状态，发现她是一名弓箭手，在性格一栏里写着’反叛’。我试着重新下达命令，但她还是没反应。眼看大部队已经撤入城门里，我开始关闭大门，心里想着不说是外面的这一个弓箭手，我的整个城堡估计也就是到今天为止了。我把状态切换到外面这个弓箭手身上，看看她到底准备做什么。她一直都站在那里没有动，而巨人很早就发现了她，正准备过去给她最后一击。接下来我看到的是，她走上了一个矮坡，转身，瞄准，射出一箭，箭矢穿过了巨人的头盔，正中头部，一击就把剩下的那个巨人干掉了。在战斗结束一切安稳后，我把她撤离了战斗部队，她在我的城堡里安详的度过了余生。当然我的城堡最后还是挂在了(某种 Dwarf Fortress 里很常见的入侵)上。” 在你反应过来之前，这里还有一个 NetHack 里叫做 DeathOnAStick 的故事： “DeathOnAStick 在 NetHack 社区里出名是因为他在 nethack.alt.org 上从 2004-04-17 到 2005-11-27 间长达一年半的一局游戏。他把大部分的时间花在了用游戏内的变形魔法以很低的几率把石头变成宝石。他弄出来了超级多的宝石以至于他得想办法召来宠物巨兽来帮他搬这些宝石，因为它们实在是太多了。后面他达到了最底层获得了 ‘Amulet of Yendor’，返回了第一层。这时他只要随意找一个出口，就可以成功的结束这次游戏，很可能成为史上宝石最多的成功完成游戏的玩家。这时他看到了超级厉害的 ‘Wizard of Yendor’，杀死了他。为了庆祝即将到来的胜利他站在刚倒下的怪物尸体上，使用了’升级药水’。结果这药水是被诅咒的(在 NetHack 里面，使用了被诅咒的升级药水的效果是往上面’升一级’到达上面一层地图。游戏内的提示信息是’你升起来，穿过了屋顶。’)。当他到达’地面层’的时候，他做的第一件事就是检查他和他宠物巨兽的物品栏。跟想象的一样，里面一个宝石都没有。这时，DeathOnAStick 原地待机了38秒。他召来的宠物巨兽在他’升级’的时候要么就是被杀死了，要么就是在层面之间传送门处卡住了。反正最终，他游戏结束时的记录里只有两个宝石。好消息是，几年后他在一次 405 小时后的游戏里，于 2010-08-16 成功结束游戏，身上有8000个宝石。” 最后一则是很久之前我在尝试写一篇关于 Dungeon Crawl Stone Soup 的文章里，想用来做开头的故事。现在看来我当时应该是相当激动才能写出这么蛋疼的东西： “擦干了短剑上的血迹，Rusty，狗头人狂战士，捡起了发着银光的一块符文。这样，他就集齐了通往 Zot 领域的钥匙。传说在那里有一件神奇的物品，只要拿到它并带回地面上，就能满足你所有的愿望。然而能走到这里来，Rusty 已经算是很走运了。时间往前倒转几分钟他，在走进这个房间时，这里还充满着可怕的怪物。幸运的是，没有人注意到了他 - 虽然地下城里没有白天夜晚的区别，就算是怪物也还是需要睡眠的。Rusty 静静的关上了门，在门边等待了一会。在确认没有怪物跟出来以后，他从背包里拿出了一张卷轴。Rusty 之前就使用过这种卷轴，它能将这一层中房间的布局准确的展现出来。他发现眼前的房间分为两层，一层就是他之前看到的，充满怪物的大房间；而后面一层则是窄窄的一条走道，其中一端是一层薄薄的墙壁。虽然 Rusty 唾弃肮脏的魔法，选择面对面与对手较量，但这地下城中一次次惊险的战斗使他深刻的体会到，要在这充满危险的地下城中生存下来光靠手里的武器绝对是不够的。在片刻的思考之后，他走到那扇墙壁前，从口袋里掏出一支魔棒，对准墙壁的方向轻轻挥了一下。魔棒尖端一阵闪光，墙壁上的砖整齐的落在地上，露出走道里一只还不知道发生了什么的兽人，以及远端地上闪光的符文。Rusty 握紧手中的短剑淡定的走上前去…” DCSS 以及大部分 RougeLike 游戏都有一个很棒的功能就是会给你每次游戏记下非常详细的 Morgue，包括你游戏结束时候的装备，在啥时候碰到了什么重要的怪物，什么时候拿到了什么道具，以及一下就能让你感慨良多的角色的死因。碰巧的是我发现 Rusty 的 Morgue 还在，这一下我非常清晰的想起来当时发生了什么。这是我第一个接近满级的角色。在往最危险的 Realm Of Zot 前进之前，我决定在 Elven Hall 这个可选的分支里再提升一下等级。这里都是等级比我低很多的高等精灵，我基本按住 Tab 快速战斗就可以了。我记得我几乎清空了一整个房间，剩下没多少血，长廊的远处还有一个。我想了想决定就过去干掉他再找地方恢复。于是我按住方向键往它那边快速前进。这时我发现我的血一路在迅速减少。我稍微有点慌，停了下来，发现剩下的那位是一个弓箭手，每次攻击伤害不高但是却出奇的准。这下我稍微有点慌了，又往反方向的跑。结果它的速度比我快，不但没跑开每几步还会被他射一箭。在最后的一个转角，我检查了一下我身上的东西。血瓶之前都用完了，只有一个传送卷轴。我想了想，深呼吸，使用了传送卷轴。最后的部分我这真想不起来了，不知道是因为 Elven Hall 最底层是传送无效还是我传送完了就落在了怪物身边，还是啥别的原因，反正就是挂了。我记得当时我在椅子上坐了一小会，站起来出去抽了一根烟，低声骂了一句操。 除此之外我印象特别深刻的就是这个弓箭手的描述 - “高等精灵弓箭手：不像其他高等精灵，他放弃了剑术和魔法，把一生都花费在了磨练弓箭技术上”。 Rogue, RougeLike, RougeLike-like哈！如果你能看到这里，那么你应该对 RougeLike 相当感兴趣了。接下来的篇幅里我会讲讲 RougeLike 这个名字的由来，其代表的定义和其他相关的东西。Rogue – 一切的开始 Glenn R. Wichman 在 A Brief History of “Rogue” 中简单的讲述了 Rogue 的由来。很有意思的是 Rogue 的诞生和流行跟 Unix 的发展竟然有很大的关系。Rogue 最初版本诞生的时间是20世纪80年代，这正好是 Unix 系统发展的一个很重要的时期。你肯定知道 Linux，那么 Unix 可以简单的看做是 Linux 的爷爷。在那个时候家庭计算机还处于初期发展阶段，家用电脑最普遍的是传奇的 Apple II，而大学里学生都是通过只有键盘和输出设备的终端机来连接到服务器上，服务器上运行的操作系统就是早期的 Unix。1980 年前后 AT&amp;T 决定把 Unix Version 7 转做商业用途。UCB 的计算机研究人员开始着手开发 BSD Unix 来作为替代。 前面提到了终端机，最早的终端机是原始到只有一个键盘和纸卷，系统的输出是一行一行的打印在纸上出来的。你可以想象当时的大部分程序就是只有不断往后输出结果的，你没有办法像现在这样用鼠标滚一下往上翻。在那个时候流行一个叫做 Adventure 的游戏，游戏的大概界面估计就像是这样： 12345West of HouseYou are standing in an open field west of a white house,with a boarded front door.There is a small mailbox here.&gt; 这一段其实是来自相同时代的著名游戏 Zork 里的。游戏通过文字描述你周围的环境，你通过输入 “向东走” 或者 “看着他” 这样的指令来进行互动。你可能想不到，这种游戏后来发展为了叫做 “Interactive Fiction” 的游戏类型，一段时间里也是主流商业游戏的宠儿。到现在几十年来不断有新作推出，每年都有世界范围的优作评选，有着非常忠实的玩家群体。 很可能是后来数码的显示器终于被发明了，UCB 的一名学生 Ken Arnold 做了一件划时代的事情：他开发了一套软件库，可以避开输出文字的限制，在屏幕任意一个地方显示指定字符。这个库就是后来的 curses，现在在所有 Linux 发行版里都有内置。curses 随着 BSD Unix 一起在大学里逐渐普及开来。在另外一间大学里， Michael Toy 和 Glenn Wichman，两位忠实的 Adventure 玩家，看到 curses 的第一反应就是：我靠这个实在是太适合用来做游戏了。在这之后 Rogue 的最初版本就诞生了。 Rogue 是一个回合制的电脑 RPG 游戏。在 Rogue 里，你扮演一个在充满怪物和宝藏的地下城中的冒险者。游戏的目标是达到最底层，取得 “Amulet of Yendor”，再返回到第一层逃出生天。作者们一直觉得 Adventure 那一类的游戏往往关卡都是固定的，没有重玩的价值，于是它们就做了随机生成的地形和关卡。游戏内角色如果死掉了的话游戏就结束了，角色的等级和装备也都就没有了。游戏里有除了各种怪物，你还可以捡到武器和护甲，以及药水，法杖和卷轴。整个游戏的界面还是以简单的英文字符构成，你需要有点想象力才能感受到 D 是一头凶猛的龙。 Rogue 的”推广”工作做的非常超前。一位开发人员把 Rogue 内置到了 BSD Unix V4.2 的操作系统中。之后在全球各地的大学花费重金购买的的计算机里，学生们在命令行里输入 rogue 就能有游戏玩。接下来的三年里，Rogue 成为了大学校园里最受欢迎的游戏。 来自过去的冲击RougeLike Restoration Project 维护着一系列可以在现代(指的就你电脑上的Win7)操作系统上运行的 Rogue。为了把这篇文章凑起来我找来 Rogue 5.4，也就是随 BSD 分发的那个版本试着玩了一下，仔细想想发现真的有很多有意思的地方。 Rogue 最突出的一个设定就是永久死亡，其原因在这个原始的版本里表现的很明确：运行程序连菜单都没有直接让你站在地牢的第一层上。角色的名字就是你系统当前登陆的账号。死掉的了话会翻几屏显示一下玩家的状态，然后程序就退出了。远一点讲这其实是很符合 Unix 风格的一个程序，只有单一的功能，执行结束了就退出。既然死了就要重来，那很自然的就会需要设计让每次游戏流程能够有丰富变化的系统。Rogue 中的地形和道具系统很大程度上都反应了这个特点。 首先 Rogue 中每一层的地图都是随机生成的。但是也许作者有些偷懒，地形方面可以说是非常简陋。每一层都是由大概 7-10 个四方形房间组成，之间用刚好玩家穿过的通道链接起来，所以说游戏里的地形跟 Rogue 的后续者们比起来算是相当单调的。普通的房间只要你踏进房间就能看清房间里所有的东西。为了有些变化有一部分房间是会被设定为黑暗的房间，你只看得到周围的8个格子。 Rogue 有着很标准的物品系统，你可以装备武器，防具和指环，消耗品包括食物，药水，卷轴和法杖。关于物品 Rogue 有一个很突出的特色就是它的鉴定系统。如果你玩过 Diablo 那你肯定知道鉴定是什么意思。Rogue 里的鉴定可以说完全就是为了重复游戏性服务的。游戏内的所有东西都可以被鉴定。对于武器和装备，虽然不鉴定玩家也可以使用，但是你看不到物品的属性。可能发生的情况就是你捡到一个闪亮的大剑，捡起来就用然后发现完全砍不到人，最后发现它带有命中率 -10 的效果。游戏中还有被诅咒的装备的设定，虽然名字听起来很可怕但效果其实就是如果你不小心装备上了这种装备那么是无法正常的脱下来的。所以如果你发现你之前拿的 -10 的大剑是被诅咒的那就很头疼了。游戏中会出现的药水，卷轴和法杖的功能是固定的，但是每次重新开始游戏的时候他们名字会被随机打散。你一开始在游戏里拿到的药水是按颜色区别的，卷轴都会付给一个随机的名字。要确定一个物品的功能只有两种办法，一个是直接使用它，另一个是使用对应的鉴定卷轴或者其他特定的道具直接鉴别物品。让这个系统闪光的地方在于，游戏里的药水和卷轴有一部分是会有反面作用的。譬如药水里有毒药和致盲的，卷轴里也有让地图上怪物全部往你这走的危险的东西。法杖主要是对敌人使用，当然你也可以对着墙上用然后反弹回来作用到自己。游戏中的法杖效果也是正面反面都有。种种东西一起作用起来，你就算玩过千百盘对游戏里所有道具和物品都无比熟悉，每次在游戏里也不敢掉以轻心。 地下城里最少不了的除了玩家当然怪物了。Rogue 中用 |, - 来勾画墙壁，# 代表通道，@ 作为玩家，其他一组符号作为各种道具，剩下的所有字母都留给了怪物。Rogue 里怪物种类不算多，除了仅有数值差别的其他还有一些怪物有特殊的攻击效果。比如很字面上的，毒蛇会让你中毒，”Ice Monster”可以冻住你，吸血鬼可以偷取你的 HP 上限等等。Rogue 以及后续的绝大部分 RougeLike 严格遵守每个字符代表一个东西，所以蝙蝠和龙看起来都一样大，这个稍微有点遗憾。 Rogue 是一个回合制的游戏，没有玩家操作的情况下游戏的世界是静止的。当你做出动作的时候就算进行了一回合，之后就轮到了怪物进行移动和攻击。游戏中战斗的方式就是邻接怪物的时候往怪物方向按移动键来”撞击”(Bump)。游戏内也有飞镖或者装备弓后射箭来进行远程攻击。除此之外你还可以投掷大部分道具来作为很业余的远程攻击。之前有提到，道具系统中有一个种类是食物，这个也就是所谓的”食物钟”(Food Clock)，它让这个看起来节奏很慢的游戏变的有些紧张。Rogue 中的 HP 恢复除了紧急时刻靠恢复药水，大部分时候都是通过原地休息，跳过当前回合来缓慢回血。每个回合都会消耗一些玩家的满腹度，如果满腹度低到一定程度就会进入虚弱的状态，玩家会时常饿晕，最后会被残酷的饿死。回复满腹度的方法显然就是吃东西了。但是食物在游戏中并不是那么容易找到，你需要关注身上的食物储备，在耗完之前找到下一个食物通常都是在地下城的更深处。Rogue 里食物的存在感很强，如果没东西吃的话你走两步就会晕一下，提示”你饿晕了”，还需要你额外按下空格确认。如果还是找不到东西的话你就得一直这样直到饿到挂，真的很残酷。 除了上面讲到的这些很有设计感的要素，Rogue 也有一些做的很随意的地方。除了简陋的游戏界面，最让普通玩家头疼的估计就是操作了。玩 Rogue 需要按的键真的就是遍布了整个键盘。你可以使用 HJKLYUBN(高端程序员会很开心的认出这是 vi 键位), 方向键和他上面的邻居或者小键盘来进行八个方向的移动。然后其他的每个操作对应一个键。比如装备武器是小写的 w，装备护甲是大写的 W，喝药水是小写的 q，戴上戒指是大写的 P。Rogue 的手册里有很自豪的写到：”游戏中的操作都能通过一到两个按键来完成”。事实上在介绍 Unix 编程的名著 《TAOUP》 里有一节专门介绍了类似 Rogue 这种操作界面的程序，这种类型的界面在书里被称为 “The Roguelike Pattern“。这样的操作设定完全免去了菜单的使用，但估计很多人看到帮助里满屏的按键就感觉玩不动了。Rogue 中有着陷阱和秘道，需要通过搜索才能找到。偶尔会有玩家一下楼就进入到一个四周没门的房间，这时你只能贴着墙来回搜索来找到隐藏的门。这个虽然看起来很有探险的感觉但实际游戏里会让人感觉很蛋疼。你还可以给任何一件道具取自己定义的名字，有些情况会强制你给东西命名。比如你喝了一个没鉴定的药水，提示你”感觉很暖和”，但药水的真实功效还是没有体现出来，这时游戏就会问你你想怎么称呼这个药水。 Rogue 本身的游戏内容不算太丰富，但却带来的一个简单却又完整而精妙的游戏模式。到这里你会想”我靠在这里面加入一个什么什么系统肯定非常棒”。显然 Rogue 火起来以后有很多人都是这么想的。Rogue 作为 Unix 文化下的产物其源代码是可以随意获取的，再加上很多玩家都是学计算机的蛋疼大学生。可以想象的，后面陆陆续续出来了很多在 Rogue 上进行加强的版本，也有另起炉灶按照 Rogue 的系统新写的游戏。这之后， Roguelike 的时代就到来了。 R O G U E L I K E首先关于 Roguelike 最重要的一点就是它的名字，是”Roguelike”这九个字母连起来(R大写与否倒是无所谓)。所以像”Rougelike真是太棒了”和”我前天玩了一个 rogue(空格或者-)like”这种真很让人伤心。 Roguelike 这个名字的来源我没有搜到相关的资料，但从这种称呼方式其实很符合很多高端大气上档次的软件项目的命名和描述习惯 - 明确的介绍软件的功能或来源。比如现在每个 Unix 环境里都有的 yacc，其中 ya 是 “Yet Another”，”只不过是另一个啥啥啥”的意思，用来表达(虚伪的)谦逊。现在逐渐流行起来的编程语言 Clojure 描述里介绍它是 Lisp 编程语言的一种衍生”方言”。 那么什么样的游戏是 Roguelike 呢？在 2008 年国际 Roguelike 开发大会上，与会的专家提出了 “Berlin Interpretation“ 作为这一游戏类型的准确定义。不过这个定义并没有看起来那么严肃，而这个国际会议好像就是 Roguelike 爱好者们的年度聚会。后面会提到 Roguelike 的开发者和玩家社区是非常有爱的一个群体。这里引用这个定义是因为我觉得它很精确地总结了一个 Roguelike 游戏应该有的特点。 Berlin Interpretation上面提到的 “Berlin Interpretation” 中提到的特性分为三个等级，这里列出高等级的一组特性，如果一个游戏的系统满足这些特性的话那基本上就可以说它是一个 “Roguelike” 游戏了： 随机生成的环境 游戏世界是以某种方式随机生成的，或者世界中的某些部分是随机生成的。这里可以包括地形，物品和怪物出现的位置等。随机生成物品和怪物如果有的话当然更好啦。随机生成的好处就是可以提高重复游戏性，所以显然的固定的谜题和剧情在这方面不是太管用。 永久死亡 一个游戏角色只有一条命。如果死掉的话这个角色就到此为止了，你只能以另一个角色的身份来重新开始游戏。对应的思路就是你必须为你的选择和失误付出代价，就像现实生活一样，哟。 回合制 与回合制相对的应该就是实时制了。回合制的游戏不应该对现实时间的流逝有反应，游戏中的世界是按照一回合一回合来运转的。这样再回合之间你可以有无限的时间进行思考。事实上，需要你停下来想上个一会儿的情况在优秀的 Roguelike 中是会经常出现的。 统一的游戏模式 (Non Modal) 这个也是从反面讲比较容易理解。像最终幻想那样在大地图上走，遇敌切换到战斗界面的游戏就是 “Modal” 的。Roguelike 要求所有操作都是在统一的一个界面上完成的，这个界面一般就是一个 2D 的地图。 复杂度 游戏允许以多种多样的方式来完成同一个目标。一个例子就是你不论选择近战或者远程还是法术路线，都可以玩的下去。 打怪练级，探索世界 每个人都喜欢这一套。我猜这里想表达的应该是游戏还是得有一个能够承载上面那些特性的主体内容。显然大部分情况下打怪练级，探索世界都是最管用的一套。 要特别提到的是一个 Roguelike 必须同时具有以上所有的特性。这就避免了”暗黑2是一个 Roguelike !” 这类的争论。同时，Rogue 也满足了这里的每一个条件。但是用规则什么的来介绍游戏实在是太没意思了，这里我想说说我对 Roguelike 游戏的感受。 荒岛问题有这样一个很常见的假想问题：”你要到一个荒岛上去度过余生，只允许你带一本书，你会带哪一本？”。对于这个问题的游戏版我现在已经有了答案：我要带上一个 Roguelike 游戏。这里不是说 Roguelike 是超越一切的终极无敌游戏类型，只是我觉得 Roguelike 太适合这种情况了。首先一个理由，荒岛上一般没有网络，所以肯定得选单机游戏吧。然后同一个游戏可能重复玩非常多次，这既是 Roguelike 能够发挥的地方了。挑一个现在主流的 Roguelike，你可能得花上一年多才能用一种职业或者路线勉强通关，之后又得花很久来一次完美通关。然后你可以依次尝试游戏里提供的其他大概二三十种路线，这样几年又混过去了。等你对游戏熟悉的不得了的时候，你又可以有新的目标了，比如随机职业连续10次通关，这样好几年又过去了。但最主要的还是， Roguelike 玩起来是真的真的很有趣啊。 永久死亡常常被拿来看做 Roguelike 最重要的一个特点。任何一个 Roguelike 都会让你经常死，但是优秀的，或者说是公平的 Roguelike 会让你认识到死亡是你的错，是你由于缺乏经验，或者粗心大意，或者更常见的太过自信而做出了错误的选择才造成了这样悲剧的结果。大部分 Roguelike 在你挂的时候会显示出你的所有道具，技能和状态。冷静下来看看你大部分情况下都会找到一个能够让你避免这次死亡的方法，接着后悔不已。另外一方面，永久死亡会给你留下深刻的印象，帮助你积累经验来增加下次游戏成功的概率。像刚开始玩的时候刚走两步就挂了当然没什么感觉，当你稍微有点上手，打了一两个小时感觉进展不错的时候突然挂掉，那时感觉就不一样了。伴随着蛋疼的感受，你还会非常清醒的记住类似”就算还有一半血也不要去惹那个双头兽人”这样具体的教训。这带来的另外一个效果就是，你在下次游戏中，避开了之前的失误的时候会非常兴奋，有一种涨经验了的感受。对于一个有着永久死亡机制的游戏，回合制显然是最合理的选择。你不会希望你因为手抖了一下或者急着上厕所来就玩挂掉。而回合制的系统也给超复杂的游戏系统发挥的空间。像我之前讲到过的，在危机时刻你可以停下来权衡各种可能性，考虑仔细后再做行动。说像下棋一样可能太夸张了，但 Roguelike 绝对算是需要你动动脑子的游戏类型。 如果你要重复玩同一个游戏，最糟糕的的情况就是就是游戏内容是完全重复的。所以像美少女文字冒险这类的游戏会通过添加剧情的分支来解决这个问题，一般像动作游戏和RPG会用不同的难度设定和多周目的隐藏内容来满足那些真的很喜欢这个游戏的玩家。Roguelike 在这方面有一个重要的优势 - 它的整个系统都是围绕”重玩价值”(Replay Value)来构思的。每次开始游戏，你面对的都是一个陌生的世界，你不会知道你固定的在哪里做什么就会获得一个牛逼道具，你需要积累经验，根据手上有的东西尽可能得走的更远。”随机生成”(Procedural Generation)是 Roguelike 重玩价值中非常重要的一个部分，在这里也需要仔细讲一下。通常来说游戏里真正是随机生成的往往只有地形，还有什么样的怪物出现在什么位置，一部分随机属性的道具。Roguelike 中显然也有固定的部分，这里通常包括技能的效果，怪物的特性和大部分可消耗品的的功能和一少部分特别出彩的装备(在 Roguelike 中通常被称为 Artifect)。正是这些固定的部分才能让你在前一次游戏中的经验能够迁移到下一次的游戏中，你也不希望上一次碰到兽人是拿斧头砍人的下一次碰到同样的一个兽人结果他变成了强力法师。随机生成的概念还包括一个容易被忽视的重要部分，就是在每次游戏的过程中，系统会从它所有可能提供的东西中抽出一个子集提供给玩家。举个简单的例子就是你在一次游戏中捡到了一把超级好用的斧头，你对它爱不释手。但是下一次开始游戏的时候，你不能确定这次游戏中能够再捡到这把斧头，他是否出现是由系统决定的。一方面这种情况会给人一种游戏”怎么也玩不完”的感觉，另一个更有意义的方面是阻止玩家总是用某种固定的模式来进行游戏，你必须学会利用手上能获得的资源来继续你的冒险。和残酷的现实生活一样，你不能选择你能拿到什么牌，只能想办法把牌打好。 讲到这里正好又能跟文章最开始游戏中”故事”的部分关联上。Roguelike 的各种特性导致游戏很难用一个预先设计好的故事串起来。一方面是很难”自动生成”一个感人的故事，还一方面是永久死亡的话不太容易跟固定的故事结合。你打了一大半突然挂掉了又得重头看一遍剧情那再精彩的故事估计都没有用。但神奇的是 Roguelike 通过另一种方式实现了”故事”这个重要的元素。Roguelike 可以依靠游戏元素的暴力堆叠，在游戏中提供足够多的可能性，而这里面总有能够让你留下深刻印象的地方。最典型的例子就是角色的死亡，有时候你犯了一个很小的错误或者不经心的举动造成一系列连锁反应就会导致悲剧的发生。对应的也有时候在看似不可能的情况下你依靠精巧的策略和一点点运气成功逃出，这些都是会让玩家笑出声或者哭到泪流的场面。说实话这一点是我个人觉得 Roguelike 最神奇的一个地方，这些”故事”把 Roguelike 的所有特性贯穿了起来：足够多的游戏内容和随机生成的世界使得意外和有趣的场面发生，回合制的进行方式让你有足够的时间思考来以最精确的方式控制游戏，而永久死亡让你游戏中的成功和失败都变得更有意义。 传统 Roguelike 游戏在界面和操作方式上仍然延续了 Rogue 的特性，即字符组成的界面和使用很多的按键来进行操作。Rogue 这种简陋的表达方式事实上有一个很微妙的副作用 - 你可以几乎无限制的往游戏里添加功能，而不需要担心像美术资源这样的问题。比如开发者想加入一种有八个头的怪物，玩家要把每个头都砍掉才能杀死他。在 Roguelike 的情况里他不需要真的画出栩栩如生的八个头，还出每个头被砍掉的效果，只要做好相关的功能，在游戏中用一个 H 来代表这个怪物就可以了。一个很有趣的情况是很多 Roguelike 的早期开发都是一个人完成的，这种简洁的表现方式使得开发不会受到各种外部因素的限制，作者可以随意构造他设想的游戏世界。正是这种无约束的开发思路才使得 Roguelike 游戏能够拥有庞大的游戏要素 - 海量的怪物种类，法术技能，装备和地形以及各种各样有特色的系统。而复杂的操作方式也是对应复杂的游戏系统最直接的解决方案。你要频繁使用大概十来个操作，显然每个按键对应一个操作比起每次打开菜单再按上下键来选功能方便很多吧。另外值得一提的是很多现代的 Roguelike 都在尝试提供简单的带真正图像的版本来吸引更多玩家，有些游戏也在实验设计基于鼠标的操作方式。 到这里为止的介绍基本上都是脱离于哪个具体的 Roguelike 游戏来说的。接下来终于到了有意思的时刻了，我会介绍下我觉得很有特点的 Roguelike 游戏，顺序是按照我对游戏的熟悉程度。对了我还没有说过，这里介绍的所有 Roguelike 游戏(除了一个明显的以外)都是可以免费获取的，就是这么棒。事实上 Roguelike 一直以来都是游离在商业游戏之外的一种游戏类型，我想你看到这里应该也能理解是为什么。 坏的，和丑的这么长的篇幅都是在说 Roguelike 的好话，但事实上现在我已经很少在真的玩 Roguelike 游戏了。而且根据在网上偶尔看到的抱怨，很多玩家也只是一直关心这个类型的发展，仅仅是在关注的游戏出新版本的时候才下下来玩一下。 就已 DCSS(Dungeon Crawl Stone Soup)为例，就我个人而言，最主要的原因我觉得是传统 Roguelike 一局的时间太长了。DCSS 就我这种水平的话随便开一局可以打二十分钟以上，如果顺利的话两三个小时没得跑了。但我现在基本都打不穿，所以大概到那个时候就因为某些蛋疼的原因死掉，然后什么都没有了。为什么网游这么多人玩，很大一部分原因就是你投入了时间后他会让你获得一些看起来很永久的东西，虽然你说不定过几个月又不玩了但是这个收获的感觉绝对就是网游比单机游戏粘人的一个巨大优势。 另一方面，系统的复杂程度也让人很蛋疼。在 DCSS 里我仍然没有成功用法师系的角色熬过 10 级。法师玩起来的感觉跟近战职业真的是天差地别，很多原来你看都不看一眼就上去砍的敌人，用法师你见面就要回头跑，跑慢一点就当场跪下这样。这个在游戏性上的确是好极了，但是对我来说我这又要花费几十个小时才能再次上手，这对我现在这种每天吃饭都是麦当劳的超快节奏人生来说实在是太痛苦了。我一直在想我要是小时候能玩到这些游戏就好了，而事实上像绝大部分 NetHack 玩家都是年龄比较大的，他们在闲的飞起的年纪花了无数的时间熟悉了这个游戏，接下来只要看看新版本的更新内容又能迅速上手。 这可能也是为什么 Roguelike-like 现在如此火爆的原因。Roguelike 的设计思路实在是太完美，特别是对于现在移动游戏短平快，重复度高的特点，任意找些 Roguelike 的东西加进来都非常管用。所以我觉得接下来会看到各种各样的新游戏在 Roguelike 里找灵感，并且大获成功。所以当下了解一下 Roguelike 对于一位高玩来说的确很有必要。 扩展阅读这最后一部分会介绍一些 Roguelike 社区的相关信息，以及一些写的很好的讲 Roguelike 的文章，如果你对 Roguelike 这个游戏类型感兴趣的话，你可以继续在这些地方进行深度的了解。 Potions And Pitfalls: My Year In Roguelikes我最开始接触 Roguelike 的时候看到的一篇文章，当时正好是 Dungeons of Dredmor 发售前后，我当时就是按着这篇一个个游戏玩下来慢慢入了 Roguelike 这个坑。 ZangbandTK: Confessions of a Dungeon Hack跟上面一篇一样也是 Rock, Paper, Shotgun 上的一篇文章。讲的是一个现在都很难下到的 ZangbandTK，但是文章写的太好让人看完马上就想去找游戏来玩。 @PlayGameSetWatch 上的一个关于 Roguelike 的专栏，作者对它讲的东西那是相当懂，有很多游戏的超深度分析，也有很多可以轻松阅读的小品。遗憾的是现在已经停止更新了，但文章很多够看一阵了。 Roguelike Radio可能是唯一一个关于 Roguelike 的 Podcast。但是质量实在是高的飞起。这里有几乎所有著名 Roguelike 游戏作者的采访。我记得有一期采访了一些在大学里研究游戏的博士和教授谈了谈他们工作的内容，感觉非常有意思。 RogueBasin虽然看上去是一个 Roguelike 开发技术的维基，但其实这边可能是最全的 Roguelike 游戏数据库，绝大部分的游戏这边都有页面简单介绍。如果你对开发也感兴趣的话这边有很好的教程 reddit.com/r/roguelikesReddit 上一个流量不大的 Roguelike 社区，感觉非常和谐友爱。大部分内容就是新的 Roguelike 相关游戏，第一次胜利的报告，还有 DCSS 和 Brogue 的每周挑战。 最后这篇超长的文章到这里就结束了。正如最开始提到的，越来越多新开发的游戏在从 Roguelike 里借鉴各种元素，以后 Roguelike 这个词毫无疑问的也会更多的出现。希望能看到这里的你能对 Roguelike 相关的东西有一个比较准确的理解。其实文中有些阐述比较武断，但你知道的游戏的东西太严肃了也没什么意思，其实还是如果能找个 Roguelike 游戏来玩一下，感受一下这个神奇的游戏类型最重要了。","tags":[{"name":"游戏","slug":"游戏","permalink":"linoahg.me/tags/游戏/"},{"name":"发展史","slug":"发展史","permalink":"linoahg.me/tags/发展史/"},{"name":"游戏类型","slug":"游戏类型","permalink":"linoahg.me/tags/游戏类型/"}]},{"title":"当你使用google搜索，按下Enter键后，发生了什么","date":"2017-04-01T09:02:39.000Z","path":"2017/04/01/WhenTheKeyDown/","text":"当···时发生了什么？这篇文章试图回答一个古老的面试问题：当你在浏览器中输入 google.com 并且按下回车之后发生了什么？ 不过我们不再局限于平常的回答，而是想办法回答地尽可能具体，不遗漏任何细节。 这将是一个协作的过程，所以深入挖掘吧，并且帮助我们一起完善它。仍然有大量的细节等待着你来添加，欢迎向我们发送 Pull Requset！ 这些内容使用 Creative Commons Zero_ 协议发布。 目录[toc] 按下”g”键接下来的内容介绍了物理键盘和系统中断的工作原理，但是有一部分内容却没有涉及。当你按下“g”键，浏览器接收到这个消息之后，会触发自动完成机制。浏览器根据自己的算法，以及你是否处于隐私浏览模式，会在浏览器的地址框下方给出输入建议。大部分算法会优先考虑根据你的搜索历史和书签等内容给出建议。你打算输入 “google.com”，因此给出的建议并不匹配。但是输入过程中仍然有大量的代码在后台运行，你的每一次按键都会使得给出的建议更加准确。甚至有可能在你输入之前，浏览器就将 “google.com” 建议给你。 回车键按下为了从零开始，我们选择键盘上的回车键被按到最低处作为起点。在这个时刻，一个专用于回车键的电流回路被直接地或者通过电容器间接地闭合了，使得少量的电流进入了键盘的逻辑电路系统。这个系统会扫描每个键的状态，对于按键开关的电位弹跳变化进行噪音消除(debounce)，并将其转化为键盘码值。在这里，回车的码值是13。键盘控制器在得到码值之后，将其编码，用于之后的传输。现在这个传输过程几乎都是通过通用串行总线(USB)或者蓝牙(Bluetooth)来进行的，以前是通过PS/2或者ADB连接进行。 USB键盘： 键盘的USB元件通过计算机上的USB接口与USB控制器相连接，USB接口中的第一号针为它提供了5V的电压 键码值存储在键盘内部电路一个叫做”endpoint”的寄存器内 USB控制器大概每隔10ms便查询一次”endpoint”以得到存储的键码值数据，这个最短时间间隔由键盘提供 键值码值通过USB串行接口引擎被转换成一个或者多个遵循低层USB协议的USB数据包 这些数据包通过D+针或者D-针(中间的两个针)，以最高1.5Mb/s的速度从键盘传输至计算机。速度限制是因为人机交互设备总是被声明成”低速设备”（USB 2.0 compliance） 这个串行信号在计算机的USB控制器处被解码，然后被人机交互设备通用键盘驱动进行进一步解释。之后按键的码值被传输到操作系统的硬件抽象层 虚拟键盘（触屏设备）： 在现代电容屏上，当用户把手指放在屏幕上时，一小部分电流从传导层的静电域经过手指传导，形成了一个回路，使得屏幕上触控的那一点电压下降，屏幕控制器产生一个中断，报告这次“点击”的坐标 然后移动操作系统通知当前活跃的应用，有一个点击事件发生在它的某个GUI部件上了，现在这个部件是虚拟键盘的按钮 虚拟键盘引发一个软中断，返回给OS一个“按键按下”消息 这个消息又返回来向当前活跃的应用通知一个“按键按下”事件 产生中断[非USB键盘]键盘在它的中断请求线(IRQ)上发送信号，信号会被中断控制器映射到一个中断向量，实际上就是一个整型数 。CPU使用中断描述符表(IDT)把中断向量映射到对应函数，这些函数被称为中断处理器，它们由操作系统内核提供。当一个中断到达时，CPU根据IDT和中断向量索引到对应的中断处理器，然后操作系统内核出场了。 (Windows)一个 WM_KEYDOWN 消息被发往应用程序HID把键盘按下的事件传送给 KBDHID.sys 驱动，把HID的信号转换成一个扫描码(Scancode)，这里回车的扫描码是 VK_RETURN(0x0d)。 KBDHID.sys 驱动和 KBDCLASS.sys (键盘类驱动,keyboard class driver)进行交互，这个驱动负责安全地处理所有键盘和小键盘的输入事件。之后它又去调用 Win32K.sys ，在这之前有可能把消息传递给安装的第三方键盘过滤器。这些都是发生在内核模式。 Win32K.sys 通过 GetForegroundWindow() API函数找到当前哪个窗口是活跃的。这个API函数提供了当前浏览器的地址栏的句柄。Windows系统的”message pump”机制调用 SendMessage(hWnd, WM_KEYDOWN, VK_RETURN, lParam) 函数， lParam 是一个用来指示这个按键的更多信息的掩码，这些信息包括按键重复次数（这里是0），实际扫描码（可能依赖于OEM厂商，不过通常不会是 VK_RETURN ），功能键（alt, shift, ctrl）是否被按下（在这里没有），以及一些其他状态。 Windows的 SendMessage API直接将消息添加到特定窗口句柄 hWnd 的消息队列中，之后赋给 hWnd 的主要消息处理函数 WindowProc 将会被调用，用于处理队列中的消息。 当前活跃的句柄 hWnd 实际上是一个edit control控件，这种情况下，WindowProc 有一个用于处理 WM_KEYDOWN 消息的处理器，这段代码会查看 SendMessage 传入的第三个参数 wParam ，因为这个参数是 VK_RETURN ，于是它知道用户按下了回车键。 (Mac OS X)一个 KeyDown NSEvent被发往应用程序中断信号引发了I/O Kit Kext键盘驱动的中断处理事件，驱动把信号翻译成键码值，然后传给OS X的 WindowServer 进程。然后， WindowServer 将这个事件通过Mach端口分发给合适的（活跃的，或者正在监听的）应用程序，这个信号会被放到应用程序的消息队列里。队列中的消息可以被拥有足够高权限的线程使用 mach_ipc_dispatch 函数读取到。这个过程通常是由 NSApplication 主事件循环产生并且处理的，通过 NSEventType 为 KeyDown 的 NSEvent 。 (GNU/Linux)Xorg 服务器监听键码值当使用图形化的 X Server 时，X Server 会按照特定的规则把键码值再一次映射，映射成扫描码。当这个映射过程完成之后， X Server 把这个按键字符发送给窗口管理器(DWM，metacity, i3等等)，窗口管理器再把字符发送给当前窗口。当前窗口使用有关图形API把文字打印在输入框内。 解析URL 浏览器通过 URL 能够知道下面的信息： Protocol “http” 使用HTTP协议 Resource “/“ 请求的资源是主页(index) 输入的是 URL 还是搜索的关键字？当协议或主机名不合法时，浏览器会将地址栏中输入的文字传给默认的搜索引擎。大部分情况下，在把文字传递给搜索引擎的时候，URL会带有特定的一串字符，用来告诉搜索引擎这次搜索来自这个特定浏览器。 转换非 ASCII 的 Unicode 字符 浏览器检查输入是否含有不是 a-z， A-Z，0-9， - 或者 . 的字符 这里主机名是 google.com ，所以没有非ASCII的字符；如果有的话，浏览器会对主机名部分使用 Punycode_ 编码 检查 HSTS 列表··· 浏览器检查自带的“预加载 HSTS（HTTP严格传输安全）”列表，这个列表里包含了那些请求浏览器只使用HTTPS进行连接的网站 如果网站在这个列表里，浏览器会使用 HTTPS 而不是 HTTP 协议，否则，最初的请求会使用HTTP协议发送 注意，一个网站哪怕不在 HSTS 列表里，也可以要求浏览器对自己使用 HSTS 政策进行访问。浏览器向网站发出第一个 HTTP 请求之后，网站会返回浏览器一个响应，请求浏览器只使用 HTTPS 发送请求。然而，就是这第一个 HTTP 请求，却可能会使用户收到 downgrade attack_ 的威胁，这也是为什么现代浏览器都预置了 HSTS 列表。 DNS 查询··· 浏览器检查域名是否在缓存当中（要查看 Chrome 当中的缓存， 打开 chrome://net-internals/#dns &lt;chrome://net-internals/#dns&gt;_）。 如果缓存中没有，就去调用 gethostbyname 库函数（操作系统不同函数也不同）进行查询。 gethostbyname 函数在试图进行DNS解析之前首先检查域名是否在本地 Hosts 里，Hosts 的位置 不同的操作系统有所不同_ 如果 gethostbyname 没有这个域名的缓存记录，也没有在 hosts 里找到，它将会向 DNS 服务器发送一条 DNS 查询请求。DNS 服务器是由网络通信栈提供的，通常是本地路由器或者 ISP 的缓存 DNS 服务器。 查询本地 DNS 服务器 如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP查询 如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询 ARP 过程要想发送 ARP（地址解析协议）广播，我们需要有一个目标 IP 地址，同时还需要知道用于发送 ARP 广播的接口的 MAC 地址。 首先查询 ARP 缓存，如果缓存命中，我们返回结果：目标 IP = MAC 如果缓存没有命中： 查看路由表，看看目标 IP 地址是不是在本地路由表中的某个子网内。是的话，使用跟那个子网相连的接口，否则使用与默认网关相连的接口。 查询选择的网络接口的 MAC 地址 我们发送一个二层（ OSI 模型_ 中的数据链路层）ARP 请求： ARP Request:: Sender MAC: interface:mac:address:here Sender IP: interface.ip.goes.here Target MAC: FF:FF:FF:FF:FF:FF (Broadcast) Target IP: target.ip.goes.here 根据连接主机和路由器的硬件类型不同，可以分为以下几种情况： 直连： 如果我们和路由器是直接连接的，路由器会返回一个 ARP Reply （见下面）。 集线器： 如果我们连接到一个集线器，集线器会把 ARP 请求向所有其它端口广播，如果路由器也“连接”在其中，它会返回一个 ARP Reply 。 交换机： 如果我们连接到了一个交换机，交换机会检查本地 CAM/MAC 表，看看哪个端口有我们要找的那个 MAC 地址，如果没有找到，交换机会向所有其它端口广播这个 ARP 请求。 如果交换机的 MAC/CAM 表中有对应的条目，交换机会向有我们想要查询的 MAC 地址的那个端口发送 ARP 请求 如果路由器也“连接”在其中，它会返回一个 ARP Reply ARP Reply:: Sender MAC: target:mac:address:here Sender IP: target.ip.goes.here Target MAC: interface:mac:address:here Target IP: interface.ip.goes.here 现在我们有了 DNS 服务器或者默认网关的 IP 地址，我们可以继续 DNS 请求了： 使用 53 端口向 DNS 服务器发送 UDP 请求包，如果响应包太大，会使用 TCP 协议 如果本地/ISP DNS 服务器没有找到结果，它会发送一个递归查询请求，一层一层向高层 DNS 服务器做查询，直到查询到起始授权机构，如果找到会把结果返回 使用套接字当浏览器得到了目标服务器的 IP 地址，以及 URL 中给出来端口号（http 协议默认端口号是 80， https 默认端口号是 443），它会调用系统库函数 socket ，请求一个TCP流套接字，对应的参数是 AF_INET/AF_INET6 和 SOCK_STREAM 。 这个请求首先被交给传输层，在传输层请求被封装成 TCP segment。目标端口会被加入头部，源端口会在系统内核的动态端口范围内选取（Linux下是ip_local_port_range) TCP segment 被送往网络层，网络层会在其中再加入一个 IP 头部，里面包含了目标服务器的IP地址以及本机的IP地址，把它封装成一个TCP packet。 这个 TCP packet 接下来会进入链路层，链路层会在封包中加入 frame头 部，里面包含了本地内置网卡的MAC地址以及网关（本地路由器）的 MAC 地址。像前面说的一样，如果内核不知道网关的 MAC 地址，它必须进行 ARP 广播来查询其地址。 到了现在，TCP 封包已经准备好了，可以使用下面的方式进行传输： 以太网_ WiFi_ 蜂窝数据网络_ 对于大部分家庭网络和小型企业网络来说，封包会从本地计算机出发，经过本地网络，再通过调制解调器把数字信号转换成模拟信号，使其适于在电话线路，有线电视光缆和无线电话线路上传输。在传输线路的另一端，是另外一个调制解调器，它把模拟信号转换回数字信号，交由下一个 网络节点_ 处理。节点的目标地址和源地址将在后面讨论。 大型企业和比较新的住宅通常使用光纤或直接以太网连接，这种情况下信号一直是数字的，会被直接传到下一个 网络节点_ 进行处理。 最终封包会到达管理本地子网的路由器。在那里出发，它会继续经过自治区域的边界路由器，其他自治区域，最终到达目标服务器。一路上经过的这些路由器会从IP数据报头部里提取出目标地址，并将封包正确地路由到下一个目的地。IP数据报头部TTL域的值每经过一个路由器就减1，如果封包的TTL变为0，或者路由器由于网络拥堵等原因封包队列满了，那么这个包会被路由器丢弃。 上面的发送和接受过程在 TCP 连接期间会发生很多次： 客户端选择一个初始序列号(ISN)，将设置了 SYN 位的封包发送给服务器端，表明自己要建立连接并设置了初始序列号 服务器端接收到 SYN 包，如果它可以建立连接： 服务器端选择它自己的初始序列号 服务器端设置 SYN 位，表明自己选择了一个初始序列号 服务器端把 (客户端ISN + 1) 复制到 ACK 域，并且设置 ACK 位，表明自己接收到了客户端的第一个封包 客户端通过发送下面一个封包来确认这次连接： 自己的序列号+1 接收端 ACK+1 设置 ACK 位 数据通过下面的方式传输： 当一方发送了N个 Bytes 的数据之后，将自己的 SEQ 序列号也增加N 另一方确认接收到这个数据包（或者一系列数据包）之后，它发送一个 ACK 包，ACK 的值设置为接收到的数据包的最后一个序列号 关闭连接时： 要关闭连接的一方发送一个 FIN 包 另一方确认这个 FIN 包，并且发送自己的 FIN 包 要关闭的一方使用 ACK 包来确认接收到了 FIN UDP 数据包12345678910111213TLS 握手--------* 客户端发送一个 ``Client hello`` 消息到服务器端，消息中同时包含了它的TLS版本，可用的加密算法和压缩算法。* 服务器端向客户端返回一个 ``Server hello`` 消息，消息中包含了服务器端的TLS版本，服务器选择了哪个加密和压缩算法，以及服务器的公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥* 客户端根据自己的信任CA列表，验证服务器端的证书是否有效。如果有效，客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称密钥* 服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥* 客户端发送一个 ``Finished`` 消息给服务器端，使用对称密钥加密这次通讯的一个散列值* 服务器端生成自己的 hash 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个 ``Finished`` 消息，也使用协商好的对称密钥加密* 从现在开始，接下来整个 TLS 会话都使用对称秘钥进行加密，传输应用层（HTTP）内容TCP 数据包~ HTTP 协议···如果浏览器是 Google 出品的，它不会使用 HTTP 协议来获取页面信息，而是会与服务器端发送请求，商讨使用 SPDY 协议。 如果浏览器使用 HTTP 协议，它会向服务器发送这样的一个请求:: GET / HTTP/1.1 Host: google.com [其他头部] “其他头部”包含了一系列的由冒号分割开的键值对，它们的格式符合HTTP协议标准，它们之间由一个换行符分割开来。这里我们假设浏览器没有违反HTTP协议标准的bug，同时浏览器使用 HTTP/1.1 协议，不然的话头部可能不包含 Host 字段，同时 GET 请求中的版本号会变成 HTTP/1.0 或者 HTTP/0.9 。 HTTP/1.1 定义了“关闭连接”的选项 “close”，发送者使用这个选项指示这次连接在响应结束之后会断开:: Connection:close 不支持持久连接的 HTTP/1.1 必须在每条消息中都包含 “close” 选项。 在发送完这些请求和头部之后，浏览器发送一个换行符，表示要发送的内容已经结束了。 服务器端返回一个响应码，指示这次请求的状态，响应的形式是这样的:: 200 OK [响应头部] 然后是一个换行，接下来有效载荷(payload)，也就是 www.google.com 的HTML内容。服务器下面可能会关闭连接，如果客户端请求保持连接的话，服务器端会保持连接打开，以供以后的请求重用。 如果浏览器发送的HTTP头部包含了足够多的信息（例如包含了 Etag 头部，以至于服务器可以判断出，浏览器缓存的文件版本自从上次获取之后没有再更改过，服务器可能会返回这样的响应:: 304 Not Modified [响应头部] 这个响应没有有效载荷，浏览器会从自己的缓存中取出想要的内容。 在解析完 HTML 之后，浏览器和客户端会重复上面的过程，直到HTML页面引入的所有资源（图片，CSS，favicon.ico等等）全部都获取完毕，区别只是头部的 GET / HTTP/1.1 会变成 GET /$(相对www.google.com的URL) HTTP/1.1 。 如果HTML引入了 www.google.com 域名之外的资源，浏览器会回到上面解析域名那一步，按照下面的步骤往下一步一步执行，请求中的 Host 头部会变成另外的域名。 HTTP 服务器请求处理HTTPD(HTTP Daemon)在服务器端处理请求/响应。最常见的 HTTPD 有 Linux 上常用的 Apache 和 nginx，以及 Windows 上的 IIS。 HTTPD 接收请求 服务器把请求拆分为以下几个参数： HTTP 请求方法(GET, POST, HEAD, PUT, DELETE, CONNECT, OPTIONS, 或者 TRACE)。直接在地址栏中输入 URL 这种情况下，使用的是 GET 方法 域名：google.com 请求路径/页面：/ (我们没有请求google.com下的指定的页面，因此 / 是默认的路径) 服务器验证其上已经配置了 google.com 的虚拟主机 服务器验证 google.com 接受 GET 方法 服务器验证该用户可以使用 GET 方法(根据 IP 地址，身份信息等) 如果服务器安装了 URL 重写模块（例如 Apache 的 mod_rewrite 和 IIS 的 URL Rewrite），服务器会尝试匹配重写规则，如果匹配上的话，服务器会按照规则重写这个请求 服务器根据请求信息获取相应的响应内容，这种情况下由于访问路径是 “/“ ,会访问首页文件（你可以重写这个规则，但是这个是最常用的）。 服务器会使用指定的处理程序分析处理这个文件，假如 Google 使用 PHP，服务器会使用 PHP 解析 index 文件，并捕获输出，把 PHP 的输出结果返回给请求者 浏览器背后的故事当服务器提供了资源之后（HTML，CSS，JS，图片等），浏览器会执行下面的操作： 解析 —— HTML，CSS，JS 渲染 —— 构建 DOM 树 -&gt; 渲染 -&gt; 布局 -&gt; 绘制 浏览器浏览器的功能是从服务器上取回你想要的资源，然后展示在浏览器窗口当中。资源通常是 HTML 文件，也可能是 PDF，图片，或者其他类型的内容。资源的位置通过用户提供的 URI(Uniform Resource Identifier) 来确定。 浏览器解释和展示 HTML 文件的方法，在 HTML 和 CSS 的标准中有详细介绍。这些标准由 Web 标准组织 W3C(World Wide Web Consortium) 维护。 不同浏览器的用户界面大都十分接近，有很多共同的 UI 元素： 一个地址栏 后退和前进按钮 书签选项 刷新和停止按钮 主页按钮 浏览器高层架构 组成浏览器的组件有： 用户界面 用户界面包含了地址栏，前进后退按钮，书签菜单等等，除了请求页面之外所有你看到的内容都是用户界面的一部分 浏览器引擎 浏览器引擎负责让 UI 和渲染引擎协调工作 渲染引擎 渲染引擎负责展示请求内容。如果请求的内容是 HTML，渲染引擎会解析 HTML 和 CSS，然后将内容展示在屏幕上 网络组件 网络组件负责网络调用，例如 HTTP 请求等，使用一个平台无关接口，下层是针对不同平台的具体实现 UI后端 UI 后端用于绘制基本 UI 组件，例如下拉列表框和窗口。UI 后端暴露一个统一的平台无关的接口，下层使用操作系统的 UI 方法实现 Javascript 引擎 Javascript 引擎用于解析和执行 Javascript 代码 数据存储 数据存储组件是一个持久层。浏览器可能需要在本地存储各种各样的数据，例如 Cookie 等。浏览器也需要支持诸如 localStorage，IndexedDB，WebSQL 和 FileSystem 之类的存储机制 HTML 解析浏览器渲染引擎从网络层取得请求的文档，一般情况下文档会分成8kB大小的分块传输。 HTML 解析器的主要工作是对 HTML 文档进行解析，生成解析树。 解析树是以 DOM 元素以及属性为节点的树。DOM是文档对象模型(Document Object Model)的缩写，它是 HTML 文档的对象表示，同时也是 HTML 元素面向外部(如Javascript)的接口。树的根部是”Document”对象。整个 DOM 和 HTML 文档几乎是一对一的关系。 解析算法 HTML不能使用常见的自顶向下或自底向上方法来进行分析。主要原因有以下几点: 语言本身的“宽容”特性 HTML 本身可能是残缺的，对于常见的残缺，浏览器需要有传统的容错机制来支持它们 解析过程需要反复。对于其他语言来说，源码不会在解析过程中发生变化，但是对于 HTML 来说，动态代码，例如脚本元素中包含的 document.write() 方法会在源码中添加内容，也就是说，解析过程实际上会改变输入的内容 由于不能使用常用的解析技术，浏览器创造了专门用于解析 HTML 的解析器。解析算法在 HTML5 标准规范中有详细介绍，算法主要包含了两个阶段：标记化（tokenization）和树的构建。 解析结束之后 浏览器开始加载网页的外部资源（CSS，图像，Javascript 文件等）。 此时浏览器把文档标记为“可交互的”，浏览器开始解析处于“推迟”模式的脚本，也就是那些需要在文档解析完毕之后再执行的脚本。之后文档的状态会变为“完成”，浏览器会进行“加载”事件。 注意解析 HTML 网页时永远不会出现“语法错误”，浏览器会修复所有错误，然后继续解析。 执行同步 Javascript 代码。 CSS 解析 根据 CSS词法和句法_ 分析CSS文件和 &lt;style&gt; 标签包含的内容 每个CSS文件都被解析成一个样式表对象，这个对象里包含了带有选择器的CSS规则，和对应CSS语法的对象 CSS解析器可能是自顶向下的，也可能是使用解析器生成器生成的自底向上的解析器 页面渲染 通过遍历DOM节点树创建一个“Frame 树”或“渲染树”，并计算每个节点的各个CSS样式值 通过累加子节点的宽度，该节点的水平内边距(padding)、边框(border)和外边距(margin)，自底向上的计算”Frame 树”中每个节点首的选(preferred)宽度 通过自顶向下的给每个节点的子节点分配可行宽度，计算每个节点的实际宽度 通过应用文字折行、累加子节点的高度和此节点的内边距(padding)、边框(border)和外边距(margin)，自底向上的计算每个节点的高度 使用上面的计算结果构建每个节点的坐标 当存在元素使用 floated，位置有 absolutely 或 relatively 属性的时候，会有更多复杂的计算，详见http://dev.w3.org/csswg/css2/ 和 http://www.w3.org/Style/CSS/current-work 创建layer(层)来表示页面中的哪些部分可以成组的被绘制，而不用被重新栅格化处理。每个帧对象都被分配给一个层 页面上的每个层都被分配了纹理(?) 每个层的帧对象都会被遍历，计算机执行绘图命令绘制各个层，此过程可能由CPU执行栅格化处理，或者直接通过D2D/SkiaGL在GPU上绘制 上面所有步骤都可能利用到最近一次页面渲染时计算出来的各个值，这样可以减少不少计算量 计算出各个层的最终位置，一组命令由 Direct3D/OpenGL发出，GPU命令缓冲区清空，命令传至GPU并异步渲染，帧被送到Window Server。 GPU 渲染 在渲染过程中，图形处理层可能使用通用用途的 CPU，也可能使用图形处理器 GPU 当使用 GPU 用于图形渲染时，图形驱动软件会把任务分成多个部分，这样可以充分利用 GPU 强大的并行计算能力，用于在渲染过程中进行大量的浮点计算。 Window Server后期渲染与用户引发的处理渲染结束后，浏览器根据某些时间机制运行JavaScript代码(比如Google Doodle动画)或与用户交互(在搜索栏输入关键字获得搜索建议)。类似Flash和Java的插件也会运行，尽管Google主页里没有。这些脚本可以触发网络请求，也可能改变网页的内容和布局，产生又一轮渲染与绘制。 .. Creative Commons Zero: https://creativecommons.org/publicdomain/zero/1.0/.. CSS词法和句法: http://www.w3.org/TR/CSS2/grammar.html.. Punycode: https://en.wikipedia.org/wiki/Punycode.. 以太网: http://en.wikipedia.org/wiki/IEEE_802.3.. _WiFi: https://en.wikipedia.org/wiki/IEEE_802.11.. _蜂窝数据网络: https://en.wikipedia.org/wiki/Cellular_data_communication_protocol.. _analog-to-digital converter: https://en.wikipedia.org/wiki/Analog-to-digital_converter.. _网络节点: https://en.wikipedia.org/wiki/Computer_network#Network_nodes.. 不同的操作系统有所不同 : https://en.wikipedia.org/wiki/Hosts%28file%29#Location_in_the_filesystem.. downgrade attack: http://en.wikipedia.org/wiki/SSL_stripping.. _OSI 模型: https://en.wikipedia.org/wiki/OSI_model","tags":[{"name":"网络","slug":"网络","permalink":"linoahg.me/tags/网络/"},{"name":"底层","slug":"底层","permalink":"linoahg.me/tags/底层/"},{"name":"技术","slug":"技术","permalink":"linoahg.me/tags/技术/"}]},{"title":"转载---关于Markdown语言测试","date":"2017-03-29T11:45:45.000Z","path":"2017/03/29/MarkDownLangRepost/","text":"欢迎使用 Cmd Markdown 编辑阅读器 我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 [ ] 支持以 PDF 格式导出文稿 [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 [x] 新增 Todo 列表功能 [x] 修复 LaTex 公式渲染问题 [x] 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \\$1600 5 手机 \\$12 12 管线 \\$1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： 通过管理工具栏可以： 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 @ghosert2016 年 07月 07日 [^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 [^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。","tags":[{"name":"markdown","slug":"markdown","permalink":"linoahg.me/tags/markdown/"},{"name":"语言","slug":"语言","permalink":"linoahg.me/tags/语言/"}]}]